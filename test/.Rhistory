cbc.df.sf = cbc.df[cbc.df$resp.id == resp.id, ]
nalts = designctx$nalternatives
covs = getdfcolumns(cbc.df.sf, cnames = names(designctx$covariates))
sf.mm = domodelmatrix_itemscovs_bwencode(cbc.df.sf$alt, covs, nalts)
items.columns = attr(sf.mm, "items.columns")
cov.columns = attr(sf.mm, "cov.columns")
cbc.mm.sf = data.frame(cbind(resp.id = bw_encode_data_1(cbc.df.sf$resp.id, nalts),
ques = rep(1:(2*max(cbc.df.sf$ques)), each = nalts),
#alt = cbc.df$alt,
alt = rep(1:nalts, nrow(sf.mm)/nalts),
sf.mm,
choice = bw_encode_data(cbc.df.sf$best_choice, cbc.df.sf$worst_choice, nalts)))
anchorcolnames = getanchorcolnames(designctx$anchors)
anchorcols = cbc.df.sf[, colnames(cbc.df.sf) %in% anchorcolnames]
best_choices = cbc.df.sf[cbc.df$best_choice == 1, ]$alt
worst_choices = cbc.df.sf[cbc.df$worst_choice == 1, ]$alt
anchors = getanchors(designctx$anchors, best_choices, worst_choices)
anch.mm = domodelmatrix_itemscovs(anchors, getdfcolumns(covs[rep(1, length(anchors)), ], cnames = colnames(covs)))
anch.mm = anch.mm[rep(1:nrow(anch.mm), each = 2), ]
anch.mm[2*(1:(nrow(anch.mm)/2)), items.columns] = 0
anch.choices = rep(t(anchorcols[1, ]), each = 2)
anch.choices[2*(1:(length(anch.choices)/2))-1][anchorcols[1, ] == 2] = 0 # neparni
anch.choices[2*(1:(length(anch.choices)/2))][anchorcols[1, ] == 1] = 0 # parni
anch.choices[2*(1:(length(anch.choices)/2))][anchorcols[1, ] == 2] = 1 # parni
anch.mm.sf = data.frame(cbind(resp.id = bw_encode_data_1(cbc.df.sf$resp.id, 2),
ques = rep(max(cbc.mm.sf$ques+1):(max(cbc.mm.sf$ques)+length(anchors)), each = 2),
alt = rep(1:2, nrow(anch.mm)/nalts),
anch.mm,
choice = anch.choices))
rep(max(cbc.mm.sf$ques+1):(max(cbc.mm.sf$ques)+length(anchors)), each = 2)
bw_encode_data_1(cbc.df.sf$resp.id, 2)
anch.mm
rep(1:2, nrow(anch.mm)/nalts)
anch.mm.sf = data.frame(cbind(resp.id = rep(resp.id, nrow(anch.mm)),
ques = rep(max(cbc.mm.sf$ques+1):(max(cbc.mm.sf$ques)+length(anchors)), each = 2),
alt = rep(1:2, nrow(anch.mm)/nalts),
anch.mm,
choice = anch.choices))
anch.choices
anch.mm
rep(1:2, nrow(anch.mm)/nalts)
anch.mm.sf = data.frame(cbind(resp.id = rep(resp.id, nrow(anch.mm)),
ques = rep(max(cbc.mm.sf$ques+1):(max(cbc.mm.sf$ques)+length(anchors)), each = 2),
alt = rep(1:2, nrow(anch.mm)/2),
anch.mm,
choice = anch.choices))
cbc.mm.sf = rbind(cbc.mm.sf, anch.mm.sf)
# petlja za svaki resp.id
# enkodirati pitanja, covariates, best+worst choice
# ako ima, enkodirati anchor pitanja kao choice, dodati na kraj data.framea za resp.id
cbc.mm = data.frame(NULL)
cbc.mm = rbind(cbc.mm, cbc.mm.sf)
# petlja za svaki resp.id
# enkodirati pitanja, covariates, best+worst choice
# ako ima, enkodirati anchor pitanja kao choice, dodati na kraj data.framea za resp.id
cbc.mm = data.frame(NULL)
for (resp.id in 1:max(cbc.df$resp.id)) {
# izvuci subframe
cbc.df.sf = cbc.df[cbc.df$resp.id == resp.id, ]
nalts = designctx$nalternatives
covs = getdfcolumns(cbc.df.sf, cnames = names(designctx$covariates))
sf.mm = domodelmatrix_itemscovs_bwencode(cbc.df.sf$alt, covs, nalts)
items.columns = attr(sf.mm, "items.columns")
cov.columns = attr(sf.mm, "cov.columns")
cbc.mm.sf = data.frame(cbind(resp.id = bw_encode_data_1(cbc.df.sf$resp.id, nalts),
ques = rep(1:(2*max(cbc.df.sf$ques)), each = nalts),
#alt = cbc.df$alt,
alt = rep(1:nalts, nrow(sf.mm)/nalts),
sf.mm,
choice = bw_encode_data(cbc.df.sf$best_choice, cbc.df.sf$worst_choice, nalts)))
if (designctx$anchors > 0) {
anchorcolnames = getanchorcolnames(designctx$anchors)
anchorcols = cbc.df.sf[, colnames(cbc.df.sf) %in% anchorcolnames]
best_choices = cbc.df.sf[cbc.df$best_choice == 1, ]$alt
worst_choices = cbc.df.sf[cbc.df$worst_choice == 1, ]$alt
anchors = getanchors(designctx$anchors, best_choices, worst_choices)
anch.mm = domodelmatrix_itemscovs(anchors, getdfcolumns(covs[rep(1, length(anchors)), ], cnames = colnames(covs)))
anch.mm = anch.mm[rep(1:nrow(anch.mm), each = 2), ]
anch.mm[2*(1:(nrow(anch.mm)/2)), items.columns] = 0
anch.choices = rep(t(anchorcols[1, ]), each = 2)
anch.choices[2*(1:(length(anch.choices)/2))-1][anchorcols[1, ] == 2] = 0 # neparni
anch.choices[2*(1:(length(anch.choices)/2))][anchorcols[1, ] == 1] = 0 # parni
anch.choices[2*(1:(length(anch.choices)/2))][anchorcols[1, ] == 2] = 1 # parni
anch.mm.sf = data.frame(cbind(resp.id = rep(resp.id, nrow(anch.mm)),
ques = rep(max(cbc.mm.sf$ques+1):(max(cbc.mm.sf$ques)+length(anchors)), each = 2),
alt = rep(1:2, nrow(anch.mm)/2),
anch.mm,
choice = anch.choices))
cbc.mm.sf = rbind(cbc.mm.sf, anch.mm.sf)
}
cbc.mm = rbind(cbc.mm, cbc.mm.sf)
}
items.columns
cov.columns
# items.columns = items.columns[-1]
#
# cbc.mm = data.frame(cbind(resp.id = bw_encode_data_1(cbc.df$resp.id, nalts),
#                           ques = rep(rep(1:(2*designctx$nquestions), each = nalts), max(cbc.df$resp.id)),
# #                          alt = cbc.df$alt,
#                           alt = rep(1:nalts, nrow(mm)/nalts),
#                           mm,
#                           choice = bw_encode_data(cbc.df$best_choice, cbc.df$worst_choice, nalts)))
#
# helper za neke situacije, npr. za stan.mc
cbc.mm.clear = cbc.mm[, items.columns]
head(cbc.mm, n = 50)
#############################################################################################################
### >>> MIXED MNL
library(mlogit)
cov.df = data.frame() # ovo spremamo da bismo kasnije mogli raditi predikciju s istim ovim ispitanicima
# here we build fml1, which will be used to create a model and model matrix for mlogit
if (length(designctx$covariates) == 0) {
fmlstring = paste("choice ~ 0 + ", paste(colnames(mm), collapse = "+")) # all vars have generic coefs
fml1 = as.formula(fmlstring)
} else {
ncov.columns = setdiff(colnames(mm), cov.columns)
fmlstring1 = paste("0 +", paste(ncov.columns, collapse = "+")) # all but covariates have generic coefs
fmlstring2 = paste("0 +", paste(cov.columns, collapse = "+")) # covariates will have alternative specific coefs
fmlstring = paste("choice ~", fmlstring1, "|", fmlstring2)
fml1 = mFormula(as.formula(fmlstring)) # ovdje je bitno da bude mFormula tako da se kod model.matrix pozove odgovarajuća funkcija!!! >> TO JE SAMO ZA mlogit, NE ZA choicemodelr!
# fmlstring = paste("choice ~ 0 + ", paste(colnames(mm), collapse = "+")) # all vars have generic coefs
# fml1 = mFormula(as.formula(fmlstring))
# fml1 = as.formula(fmlstring)
repeats = designctx$nquestions * designctx$nalternatives
respondents = max(cbc.df$resp.id)
cov.df = as.data.frame(cbc.df[(0:(respondents-1))*repeats+1, colnames(cbc.df) %in% names(designctx$covariates)])
colnames(cov.df) = names(designctx$covariates)
}
vars_i = 4:(ncol(cbc.mm)-1) # skip over the first three: resp.id, ques, alt
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i, alt.var = "alt",
#                         alt.levels = levels(cbc.mm$alt),
id.var = "resp.id")
rownames(cbc.mm) = c()
# items.columns = items.columns[-1]
#
# cbc.mm = data.frame(cbind(resp.id = bw_encode_data_1(cbc.df$resp.id, nalts),
#                           ques = rep(rep(1:(2*designctx$nquestions), each = nalts), max(cbc.df$resp.id)),
# #                          alt = cbc.df$alt,
#                           alt = rep(1:nalts, nrow(mm)/nalts),
#                           mm,
#                           choice = bw_encode_data(cbc.df$best_choice, cbc.df$worst_choice, nalts)))
#
# helper za neke situacije, npr. za stan.mc
cbc.mm.clear = cbc.mm[, items.columns]
vars_i = 4:(ncol(cbc.mm)-1) # skip over the first three: resp.id, ques, alt
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i, alt.var = "alt",
#                         alt.levels = levels(cbc.mm$alt),
id.var = "resp.id")
rownames(cbc.mm)
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i,
#alt.var = "alt",
alt.levels = levels(cbc.mm$alt),
id.var = "resp.id")
levels(cbc.mm$alt)
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i,
#alt.var = "alt",
alt.levels = levels(factor(cbc.mm$alt)),
id.var = "resp.id")
## BUILD AND SAVE MODEL
# Ako imamo covariates, onda model prolazi samo ako se koeficijenti covariates računaju kao alternative specific
# (znači u formuli idu iza | i s 0 +)
m1 = mlogit(fml1, data = cbc.mlogit)
str(cbc.mm$alt)
cbc.mm$alt = factor(cbc.mm$alt)
vars_i = 4:(ncol(cbc.mm)-1) # skip over the first three: resp.id, ques, alt
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i,
alt.var = "alt",
#alt.levels = levels(factor(cbc.mm$alt)),
id.var = "resp.id")
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i,
#alt.var = "alt",
alt.levels = levels(factor(cbc.mm$alt)),
id.var = "resp.id")
## BUILD AND SAVE MODEL
# Ako imamo covariates, onda model prolazi samo ako se koeficijenti covariates računaju kao alternative specific
# (znači u formuli idu iza | i s 0 +)
m1 = mlogit(fml1, data = cbc.mlogit)
#############################################################################################################
### >>> HIERARCHICAL BAYES
library(ChoiceModelR)
# # modeliranje
cmr_choice = rep(0, nrow(cbc.mm))
cmr_choice[cbc.mm$alt == 1] = cbc.mm[cbc.mm$choice == 1, "alt"]
cmr.mm = cbind(cbc.mm[, colnames(cbc.mm) != "choice"], cmr_choice)
cmr.mm.bez.cov = cmr.mm[, !(colnames(cmr.mm) %in% cov.columns)]
demos = NULL
if (length(designctx$covariates) > 0) {
# zbog ponavljanja demografije u redovima, trebamo izvaditi samo 1., 2., ... max(resp.id)
max_resp_id = max(cmr.mm$resp.id)
total_rows = nrow(cmr.mm)
demos = as.matrix(cmr.mm[(0:(max_resp_id-1))*(total_rows/max_resp_id)+1, cov.columns])
}
## Build and save the model
if (!is.null(demos)) {
hb.post = choicemodelr(data = cmr.mm.bez.cov,
xcoding = rep(1, ncol(cmr.mm.bez.cov) - 4),
demos = demos,
mcmc = list(R = 20000, use = 10000),
options = list(save = TRUE))
} else {
hb.post = choicemodelr(data = cmr.mm.bez.cov,
xcoding = rep(1, ncol(cmr.mm.bez.cov) - 4),
mcmc = list(R = 20000, use = 10000),
options = list(save = TRUE))
}
# petlja za svaki resp.id
# enkodirati pitanja, covariates, best+worst choice
# ako ima, enkodirati anchor pitanja kao choice, dodati na kraj data.framea za resp.id
cbc.mm = data.frame(NULL)
for (resp.id in 1:max(cbc.df$resp.id)) {
# izvuci subframe
cbc.df.sf = cbc.df[cbc.df$resp.id == resp.id, ]
nalts = designctx$nalternatives
covs = getdfcolumns(cbc.df.sf, cnames = names(designctx$covariates))
sf.mm = domodelmatrix_itemscovs_bwencode(cbc.df.sf$alt, covs, nalts)
items.columns = attr(sf.mm, "items.columns")
cov.columns = attr(sf.mm, "cov.columns")
cbc.mm.sf = data.frame(cbind(resp.id = bw_encode_data_1(cbc.df.sf$resp.id, nalts),
ques = rep(1:(2*max(cbc.df.sf$ques)), each = nalts),
#alt = cbc.df$alt,
alt = rep(1:nalts, nrow(sf.mm)/nalts),
sf.mm,
choice = bw_encode_data(cbc.df.sf$best_choice, cbc.df.sf$worst_choice, nalts)))
if (designctx$anchors > 0) {
anchorcolnames = getanchorcolnames(designctx$anchors)
anchorcols = cbc.df.sf[, colnames(cbc.df.sf) %in% anchorcolnames]
best_choices = cbc.df.sf[cbc.df$best_choice == 1, ]$alt
worst_choices = cbc.df.sf[cbc.df$worst_choice == 1, ]$alt
anchors = getanchors(designctx$anchors, best_choices, worst_choices)
anch.mm = domodelmatrix_itemscovs(anchors, getdfcolumns(covs[rep(1, length(anchors)), ], cnames = colnames(covs)))
anch.mm = anch.mm[rep(1:nrow(anch.mm), each = 2), ]
anch.mm[2*(1:(nrow(anch.mm)/2)), items.columns] = 0
anch.choices = rep(t(anchorcols[1, ]), each = 2)
anch.choices[2*(1:(length(anch.choices)/2))-1][anchorcols[1, ] == 2] = 0 # neparni
anch.choices[2*(1:(length(anch.choices)/2))][anchorcols[1, ] == 1] = 0 # parni
anch.choices[2*(1:(length(anch.choices)/2))][anchorcols[1, ] == 2] = 1 # parni
anch.mm.sf = data.frame(cbind(resp.id = rep(resp.id, nrow(anch.mm)),
ques = rep(max(cbc.mm.sf$ques+1):(max(cbc.mm.sf$ques)+length(anchors)), each = 2),
alt = rep(1:2, nrow(anch.mm)/2),
anch.mm,
choice = anch.choices))
cbc.mm.sf = rbind(cbc.mm.sf, anch.mm.sf)
}
cbc.mm = rbind(cbc.mm, cbc.mm.sf)
}
rownames(cbc.mm) = c()
# items.columns = items.columns[-1]
#
# cbc.mm = data.frame(cbind(resp.id = bw_encode_data_1(cbc.df$resp.id, nalts),
#                           ques = rep(rep(1:(2*designctx$nquestions), each = nalts), max(cbc.df$resp.id)),
# #                          alt = cbc.df$alt,
#                           alt = rep(1:nalts, nrow(mm)/nalts),
#                           mm,
#                           choice = bw_encode_data(cbc.df$best_choice, cbc.df$worst_choice, nalts)))
#
# helper za neke situacije, npr. za stan.mc
cbc.mm.clear = cbc.mm[, items.columns]
cov.df = data.frame() # ovo spremamo da bismo kasnije mogli raditi predikciju s istim ovim ispitanicima
# here we build fml1, which will be used to create a model and model matrix for mlogit
if (length(designctx$covariates) == 0) {
fmlstring = paste("choice ~ 0 + ", paste(colnames(mm), collapse = "+")) # all vars have generic coefs
fml1 = as.formula(fmlstring)
} else {
ncov.columns = setdiff(colnames(mm), cov.columns)
fmlstring1 = paste("0 +", paste(ncov.columns, collapse = "+")) # all but covariates have generic coefs
fmlstring2 = paste("0 +", paste(cov.columns, collapse = "+")) # covariates will have alternative specific coefs
fmlstring = paste("choice ~", fmlstring1, "|", fmlstring2)
fml1 = mFormula(as.formula(fmlstring)) # ovdje je bitno da bude mFormula tako da se kod model.matrix pozove odgovarajuća funkcija!!! >> TO JE SAMO ZA mlogit, NE ZA choicemodelr!
# fmlstring = paste("choice ~ 0 + ", paste(colnames(mm), collapse = "+")) # all vars have generic coefs
# fml1 = mFormula(as.formula(fmlstring))
# fml1 = as.formula(fmlstring)
repeats = designctx$nquestions * designctx$nalternatives
respondents = max(cbc.df$resp.id)
cov.df = as.data.frame(cbc.df[(0:(respondents-1))*repeats+1, colnames(cbc.df) %in% names(designctx$covariates)])
colnames(cov.df) = names(designctx$covariates)
}
cmr_choice = rep(0, nrow(cbc.mm))
cmr_choice[cbc.mm$alt == 1] = cbc.mm[cbc.mm$choice == 1, "alt"]
cmr.mm = cbind(cbc.mm[, colnames(cbc.mm) != "choice"], cmr_choice)
cmr.mm.bez.cov = cmr.mm[, !(colnames(cmr.mm) %in% cov.columns)]
demos = NULL
if (length(designctx$covariates) > 0) {
# zbog ponavljanja demografije u redovima, trebamo izvaditi samo 1., 2., ... max(resp.id)
max_resp_id = max(cmr.mm$resp.id)
total_rows = nrow(cmr.mm)
demos = as.matrix(cmr.mm[(0:(max_resp_id-1))*(total_rows/max_resp_id)+1, cov.columns])
}
## Build and save the model
if (!is.null(demos)) {
hb.post = choicemodelr(data = cmr.mm.bez.cov,
xcoding = rep(1, ncol(cmr.mm.bez.cov) - 4),
demos = demos,
mcmc = list(R = 20000, use = 10000),
options = list(save = TRUE))
} else {
hb.post = choicemodelr(data = cmr.mm.bez.cov,
xcoding = rep(1, ncol(cmr.mm.bez.cov) - 4),
mcmc = list(R = 20000, use = 10000),
options = list(save = TRUE))
}
beta.post.mean = apply(hb.post$betadraw, 1:2, mean) # izračun svih prosječnih koeficijenata za svakog ispitanika
sm_means = apply(t(beta.post.mean), 1, mean)
beta.post.q25 = apply(hb.post$betadraw, 1:2, quantile, probs = c(0.25)) # isto kao gore, samo 25% kvantil
beta.post.q25 = apply(hb.post$betadraw, 1:2, quantile, probs = c(0.25)) # isto kao gore, samo 25% kvantil
beta.post.q75 = apply(hb.post$betadraw, 1:2, quantile, probs = c(0.75)) # isto kao gore, samo 75% kvantil
sm_q25 = apply(t(beta.post.q25), 1, mean)
sm_q75 = apply(t(beta.post.q75), 1, mean)
sm.hb = cbind("1st Qu." = sm_q25, "Mean" = sm_means, "3rd Qu." = sm_q75)
rownames(sm.hb) = setdiff(colnames(cmr.mm.bez.cov), c("resp.id", "ques", "alt", "cmr_choice"))
sm.hb
simcoefs
str(simcoefs)
apply(simcoefs, 2, mean)
sm.hb
vars_i = 4:(ncol(cbc.mm)-1) # skip over the first three: resp.id, ques, alt
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i,
#alt.var = "alt",
alt.levels = levels(factor(cbc.mm$alt)),
id.var = "resp.id")
head(cbc.mm)
head(cbc.mm, n = 50)
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i,
alt.var = "alt",
#alt.levels = levels(factor(cbc.mm$alt)),
id.var = "resp.id")
unique(cbc.mm$alt)
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i,
#alt.var = "alt",
#alt.levels = levels(factor(cbc.mm$alt)),
alt.levels = unique(cbc.mm$alt),
id.var = "resp.id")
## BUILD AND SAVE MODEL
# Ako imamo covariates, onda model prolazi samo ako se koeficijenti covariates računaju kao alternative specific
# (znači u formuli idu iza | i s 0 +)
m1 = mlogit(fml1, data = cbc.mlogit)
cbc.mlogit = mlogit.data(data = cbc.mm[36, ], choice = "choice", shape = "long", varying = vars_i,
#alt.var = "alt",
#alt.levels = levels(factor(cbc.mm$alt)),
alt.levels = unique(cbc.mm$alt),
id.var = "resp.id")
cbc.mlogit = mlogit.data(data = cbc.mm[1:36, ], choice = "choice", shape = "long", varying = vars_i,
#alt.var = "alt",
#alt.levels = levels(factor(cbc.mm$alt)),
alt.levels = unique(cbc.mm$alt),
id.var = "resp.id")
## BUILD AND SAVE MODEL
# Ako imamo covariates, onda model prolazi samo ako se koeficijenti covariates računaju kao alternative specific
# (znači u formuli idu iza | i s 0 +)
m1 = mlogit(fml1, data = cbc.mlogit)
cbc.mlogit = mlogit.data(data = cbc.mm[1:46, ], choice = "choice", shape = "long", varying = vars_i,
#alt.var = "alt",
#alt.levels = levels(factor(cbc.mm$alt)),
alt.levels = unique(cbc.mm$alt),
id.var = "resp.id")
cbc.mlogit = mlogit.data(data = cbc.mm[1:46, ], choice = "choice", shape = "long", varying = vars_i,
alt.var = "alt",
#alt.levels = levels(factor(cbc.mm$alt)),
#alt.levels = unique(cbc.mm$alt),
id.var = "resp.id")
cbc.mlogit = mlogit.data(data = cbc.mm[1:46, ], choice = "choice", shape = "long", varying = vars_i,
#alt.var = "alt",
#alt.levels = levels(factor(cbc.mm$alt)),
alt.levels = unique(cbc.mm$alt),
id.var = "resp.id")
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i,
#alt.var = "alt",
#alt.levels = levels(factor(cbc.mm$alt)),
alt.levels = unique(cbc.mm$alt),
id.var = "resp.id")
head(cbc.mlogit)
head(cbc.mlogit, n = 50)
head(cbc.mlogit, n = 60)
debugSource('C:/OnlineSync/Mega/R/work/maxdiff/test/temp.R', encoding = 'UTF-8')
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i,
alt.var = "alt",
#alt.levels = levels(factor(cbc.mm$alt)),
chid.var = "ques",
id.var = "resp.id")
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i,
alt.var = "alt",
alt.levels = levels(factor(cbc.mm$alt)),
chid.var = "ques",
id.var = "resp.id")
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i,
#alt.var = "alt",
alt.levels = levels(factor(cbc.mm$alt)),
chid.var = "ques",
id.var = "resp.id")
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i,
#alt.var = "alt",
alt.levels = levels(factor(cbc.mm$alt)),
#chid.var = "ques",
id.var = "resp.id")
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i,
#alt.var = "alt",
alt.levels = levels(factor(cbc.mm$alt)),
chid.var = "ques",
id.var = "resp.id")
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i,
#alt.var = "alt",
#alt.levels = levels(factor(cbc.mm$alt)),
chid.var = "ques",
id.var = "resp.id")
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i,
#alt.var = "alt",
#alt.levels = levels(factor(cbc.mm$alt)),
alt.levels = unique(cbc.mm$alt),
chid.var = "ques",
id.var = "resp.id")
head(cbc.mm)
head(cbc.mm, n =50)
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long", varying = vars_i,
#alt.var = "alt",
#alt.levels = levels(factor(cbc.mm$alt)),
alt.levels = unique(cbc.mm$alt),
chid.var = "ques",
id.var = "resp.id")
debugSource('C:/OnlineSync/Mega/R/work/maxdiff/test/temp.R', encoding = 'UTF-8')
chid
paste(chid, alt, sep = ".")
paste(cbc.mm$resp.id, ".", cbc.mm$ques, sep = "")
cbc.mm$resp.ques = paste(cbc.mm$resp.id, ".", cbc.mm$ques, sep = "")
head(cbc.mm)
cbc.mlogit = mlogit.data(data = cbc.mm, choice = "choice", shape = "long",
#varying = vars_i,
alt.var = "alt",
#alt.levels = levels(factor(cbc.mm$alt)),
#alt.levels = unique(cbc.mm$alt),
chid.var = "resp.ques",
id.var = "resp.id")
## BUILD AND SAVE MODEL
# Ako imamo covariates, onda model prolazi samo ako se koeficijenti covariates računaju kao alternative specific
# (znači u formuli idu iza | i s 0 +)
m1 = mlogit(fml1, data = cbc.mlogit)
summary(m1)
# summary(m1)
m1.rpar = rep("n", length = length(m1$coef)) # 'n' normal, 'l' log-normal, 't' truncated normal, 'u' uniform
names(m1.rpar) = names(m1$coef)
m2.hier = mlogit(fml1, data = cbc.mlogit, panel = TRUE, rpar = m1.rpar, correlation = TRUE)
# summary(m1.hier)
# m2.hier = update(m1.hier, correlation = TRUE)
# summary(m2.hier)
# SAVE/LOAD
m2.hier$cov.df = cov.df
saveRDS(m2.hier, mnlmodelfile)
sm.mnl = summary(m2.hier)$summary.rpar
print(sm.mnl[, !(colnames(sm.mnl) %in% c("Min.", "Median", "Max."))])
# # modeliranje
cmr_choice = rep(0, nrow(cbc.mm))
cmr_choice[cbc.mm$alt == 1] = cbc.mm[cbc.mm$choice == 1, "alt"]
cmr.mm = cbind(cbc.mm[, colnames(cbc.mm) != "choice"], cmr_choice)
cmr.mm.bez.cov = cmr.mm[, !(colnames(cmr.mm) %in% cov.columns)]
demos = NULL
if (length(designctx$covariates) > 0) {
# zbog ponavljanja demografije u redovima, trebamo izvaditi samo 1., 2., ... max(resp.id)
max_resp_id = max(cmr.mm$resp.id)
total_rows = nrow(cmr.mm)
demos = as.matrix(cmr.mm[(0:(max_resp_id-1))*(total_rows/max_resp_id)+1, cov.columns])
}
## Build and save the model
if (!is.null(demos)) {
hb.post = choicemodelr(data = cmr.mm.bez.cov,
xcoding = rep(1, ncol(cmr.mm.bez.cov) - 4),
demos = demos,
mcmc = list(R = 20000, use = 10000),
options = list(save = TRUE))
} else {
hb.post = choicemodelr(data = cmr.mm.bez.cov,
xcoding = rep(1, ncol(cmr.mm.bez.cov) - 4),
mcmc = list(R = 20000, use = 10000),
options = list(save = TRUE))
}
## LOAD MODEL
if (!is.null(cbc.mm$resp.ques)) cbc.mm$resp.ques = NULL
# # modeliranje
cmr_choice = rep(0, nrow(cbc.mm))
cmr_choice[cbc.mm$alt == 1] = cbc.mm[cbc.mm$choice == 1, "alt"]
cmr.mm = cbind(cbc.mm[, colnames(cbc.mm) != "choice"], cmr_choice)
cmr.mm.bez.cov = cmr.mm[, !(colnames(cmr.mm) %in% cov.columns)]
demos = NULL
if (length(designctx$covariates) > 0) {
# zbog ponavljanja demografije u redovima, trebamo izvaditi samo 1., 2., ... max(resp.id)
max_resp_id = max(cmr.mm$resp.id)
total_rows = nrow(cmr.mm)
demos = as.matrix(cmr.mm[(0:(max_resp_id-1))*(total_rows/max_resp_id)+1, cov.columns])
}
## Build and save the model
if (!is.null(demos)) {
hb.post = choicemodelr(data = cmr.mm.bez.cov,
xcoding = rep(1, ncol(cmr.mm.bez.cov) - 4),
demos = demos,
mcmc = list(R = 20000, use = 10000),
options = list(save = TRUE))
} else {
hb.post = choicemodelr(data = cmr.mm.bez.cov,
xcoding = rep(1, ncol(cmr.mm.bez.cov) - 4),
mcmc = list(R = 20000, use = 10000),
options = list(save = TRUE))
}
saveRDS(hb.post, hbmodelfile)
hb.post = readRDS(hbmodelfile)
beta.post.mean = apply(hb.post$betadraw, 1:2, mean) # izračun svih prosječnih koeficijenata za svakog ispitanika
sm_means = apply(t(beta.post.mean), 1, mean)
beta.post.q25 = apply(hb.post$betadraw, 1:2, quantile, probs = c(0.25)) # isto kao gore, samo 25% kvantil
beta.post.q25 = apply(hb.post$betadraw, 1:2, quantile, probs = c(0.25)) # isto kao gore, samo 25% kvantil
beta.post.q75 = apply(hb.post$betadraw, 1:2, quantile, probs = c(0.75)) # isto kao gore, samo 75% kvantil
beta.post.q75 = apply(hb.post$betadraw, 1:2, quantile, probs = c(0.75)) # isto kao gore, samo 75% kvantil
sm_q25 = apply(t(beta.post.q25), 1, mean)
sm_q75 = apply(t(beta.post.q75), 1, mean)
sm.hb = cbind("1st Qu." = sm_q25, "Mean" = sm_means, "3rd Qu." = sm_q75)
rownames(sm.hb) = setdiff(colnames(cmr.mm.bez.cov), c("resp.id", "ques", "alt", "cmr_choice"))
sm.hb
